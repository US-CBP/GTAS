/*
 * All GTAS code is Copyright 2016, The Department of Homeland Security (DHS), U.S. Customs and Border Protection (CBP).
 * 
 * Please see LICENSE.txt for details.
 */
package gov.gtas.job.scheduler;

/*
 * All GTAS code is Copyright 2016, The Department of Homeland Security (DHS), U.S. Customs and Border Protection (CBP).
 * 
 * Please see LICENSE.txt for details.
 */
import static gov.gtas.constant.GtasSecurityConstants.GTAS_APPLICATION_USERID;

import gov.gtas.constant.RuleServiceConstants;
import gov.gtas.enumtype.AuditActionType;
import gov.gtas.error.ErrorDetailInfo;
import gov.gtas.error.ErrorHandlerFactory;
import gov.gtas.json.AuditActionData;
import gov.gtas.json.AuditActionTarget;
import gov.gtas.model.MessageStatus;
import gov.gtas.repository.MessageStatusRepository;
import gov.gtas.services.*;
import gov.gtas.services.matcher.MatchingService;
import gov.gtas.svc.TargetingService;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.apache.commons.io.comparator.LastModifiedFileComparator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * Message Loader Scheduler class. Using Spring's Scheduled annotation for
 * scheduling tasks. The class reads configuration values from an external file.
 *
 */
@Component
public class LoaderScheduler {

	private static final Logger logger = LoggerFactory
			.getLogger(LoaderScheduler.class);

	/**
	 * The Enum InputType.
	 */
	public enum InputType {
		TWO_DIRS("two_dirs");
		private final String stringValue;

		private InputType(final String s) {
			stringValue = s;
		}

		@Override
		public String toString() {
			return stringValue;
		}
	}
	
	@Autowired
	private TargetingService targetingService;

	@Autowired
	private Loader loader;

	@Autowired
	private ErrorPersistenceService errorPersistenceService;

	@Autowired
	private AuditLogPersistenceService auditLogPersistenceService;
	
	@Autowired
	private MatchingService matchingService;

	@Autowired
	private MessageStatusRepository messageStatusRepository;


	@Value("${message.dir.origin}")
	private String messageOriginDir;

	@Value("${message.dir.processed}")
	private String messageProcessedDir;

	@Value("${inputType}")
	private String inputType;
	
	@Value("${maxNumofFiles}")
	private int maxNumofFiles;

	private void processSingleFile(File f, LoaderStatistics stats, String[] primeFlightKey) {
		logger.debug(String.format("Processing %s", f.getAbsolutePath()));
		ProcessedMessages processedMessages = loader.processMessage(f, primeFlightKey);
		int[] result = processedMessages.getProcessed();
		List<MessageStatus> messageStatusList = processedMessages.getMessageStatusList();
		messageStatusRepository.saveAll(messageStatusList);
		if (result != null) {
			stats.incrementNumFilesProcessed();
			stats.incrementNumMessagesProcessed(result[0]);
			stats.incrementNumMessagesFailed(result[1]);
		} else {
			stats.incrementNumFilesAborted();
		}
	}
	//Method to be processed in thread generated by JMS listener
	public void receiveMessage(String text, String fileName, String[] primeFlightKey){
		LoaderStatistics stats = new LoaderStatistics();
		logger.debug("MESSAGE RECEIVED FROM QUEUE: "+ fileName);
		Path dOutputDir = Paths.get(messageProcessedDir).normalize();
		File f = new File(dOutputDir + File.separator + fileName);
		FileWriter fw;
		try {
			fw = new FileWriter(f, false);
			fw.write(text);
			fw.close();
		} catch (IOException e) {
			logger.error("error receiving message", e);
		}
		processSingleFile(f, stats, primeFlightKey);
	}
	/**
	 * Writes the audit log with run statistics.
	 * 
	 * @param stats
	 *            the statistics bean.
	 */
	private void writeAuditLog(LoaderStatistics stats) {
		AuditActionTarget target = new AuditActionTarget(
				AuditActionType.LOADER_RUN, "GTAS Message Loader", null);
		AuditActionData actionData = new AuditActionData();
		actionData.addProperty("totalFilesProcessed",
				String.valueOf(stats.getNumFilesProcessed()));
		actionData.addProperty("totalFilesAborted",
				String.valueOf(stats.getNumFilesAborted()));
		actionData.addProperty("totalMessagesProcessed",
				String.valueOf(stats.getNumMessagesProcessed()));
		actionData.addProperty("totalMessagesInError",
				String.valueOf(stats.getNumMessagesFailed()));

		String message = "Message Loader run on " + new Date();
		auditLogPersistenceService.create(AuditActionType.LOADER_RUN, target,
				actionData, message, GTAS_APPLICATION_USERID);
	}
}
