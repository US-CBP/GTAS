# Logstash configuration for creating a simple
# MariaDB -> Logstash -> Elasticsearch pipeline.

input {
  jdbc {
    jdbc_connection_string => "jdbc:mariadb://${MARIADB_HOST}:3306/gtas?sessionVariables=sql_mode=ANSI_QUOTES"
    jdbc_user => "${MARIADB_USER}"
    jdbc_password => "${MARIADB_PASSWORD}"
    sql_log_level => "debug"
    # jdbc_driver_library => "${LOGSTASH_LIB}/mariadb-java-client-2.3.0.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    statement_filepath => "${LOGSTASH_DIR}/config/flightpax_script.sql"
    #schedule => "* * * * *"
    schedule => "*/25 * * * * *"
    jdbc_paging_enabled => true
    jdbc_page_size => "2000"
    tracking_column_type => "numeric"
    use_column_value => true
    tracking_column => "p_id"
    last_run_metadata_path => "/mnt/flightpax_last_run_config"
  }
}

filter {
  
  aggregate {
    task_id => "%{id}"
    code => "
      map['id'] = event.get('id')
      map['eta'] = event.get('flight.eta')
      map['carrier'] = event.get('flight.carrier')
      map['etd'] = event.get('flight.etd')
      map['flightNumber'] = event.get('flight.flight_number')
      map['flightDate'] = event.get('flight.flight_date')
      map['residencyCountry'] = event.get('residency_country')
      map['flightId'] = event.get('flight.id')
      map['origin'] = event.get('flight.origin')
      map['destination'] = event.get('flight.destination')
      map['nationality'] = event.get('p_nationality')
      map['debarkation'] = event.get('p_debarkation')
      map['embarkation'] = event.get('p_embarkation')
      map['gender'] = event.get('p_gender')
      map['firstName'] = event.get('first_name')
      map['middleName'] = event.get('middle_name')
      map['dob'] = event.get('p_dob')
      map['lastName'] = event.get('last_name')
      map['passengerId'] = event.get('p_id')
      map['passengerType'] = event.get('passenger_type')
      map['direction'] =event.get('flight.direction')
      map['seatNumber'] =event.get('passenger.seat_number')
      
      if(event.get('pnr') != nil)
        map['pnr'] = event.get('pnr')
      end

      if(event.get('apis') != nil)
        map['apis'] = event.get('apis')
      end

      
      map['documents'] ||= []
      map['addresses'] ||= []
      map['watchlist_match'] ||= []

      if(event.get('d_document_id') != nil)
        document_exists = map['documents'].any? { |doc| doc['id'] == event.get('d_document_id') }

        # if(!document_exists)
          map['documents'].push({
            'id' => event.get('d_document_id'),
            'documentNumber' => event.get('d_document_number'),
            'documentType' => event.get('d_document_type'),
            'expirationDate' => event.get('d_expiration_date'),
            'firstName' => event.get('first_name'),
            'issuanceCountry' => event.get('d_issuance_country'),
            'issuanceDate' => event.get('d_issuance_date'),
            'lastName' => event.get('last_name')
          })
      #   end
      end

      if(event.get('address.id') != nil)
        address_exists = map['addresses'].any? { |address| address['id'] == event.get('address.id')}

        if(!address_exists)
          map['addresses'].push({
            'id' => event.get('address.id'),
            'country' => event.get('address.country'),
            'createdAt' => event.get('address.created_at'),
            'city' => event.get('address.city'),
            'createdBy' => event.get('address.created_by'),
            'postalCode' => event.get('address.postal_code'),
            'flightPaxList' => event.get('address.flightPaxList'),
            'state' => event.get('address.state'),
            'pnrs' => event.get('address.pnrs'),
            'line1' => event.get('address.line1'),
            'line2' => event.get('address.line2'),
            'line3' => event.get('address.line3')
          })
        end
      end

      if(event.get('pax_watchlist.id') != nil)
        watchlist_exists = map['watchlist_match'].any? { |watchlist| watchlist['id'] == event.get('pax_watchlist.id')}

        if(!watchlist_exists)
          map['watchlist_match'].push({
            'id' => event.get('pax_watchlist.id'),
            'last_run_timestamp' => event.get('pax_watchlist.hit_detail.created_date'),
            'passenger_id' => event.get('hit_detail.passenger'),
            'percent_match' => event.get('pax_watchlist.percent_match'),
            'verified_status' => event.get('hit_detail.percentage_match')
          })
        end
      end

    event.cancel()
    "
    push_previous_map_as_event => true
    
    timeout => 5
    map_action => create_or_update
    timeout_tags => ["aggregate"]
  }

  if "aggregate" not in [tags] {
		drop{}
	}

  mutate {
    remove_field => [ 
     "tags","flight_number","message_id"
    ]
    # add_field => {
    #   "[hit_disposition][comments]" => "comments"
    # }
    
    # rename => {
    #    "documents.issuance_country" => "documents.issuanceCountry"
    # }
  }

  
}


output {

  elasticsearch {
    hosts => ["${ELASTIC_HOST}"]
    index => "flightpax"
    action => "update"
    document_id => "%{id}"
    doc_as_upsert => true
    user => "elastic"
    password => "${ES_PASSWORD}"
    template => "${LOGSTASH_DIR}/config/flightpax_template.json"
    template_name => "flightpax_template"
    template_overwrite => true
    ssl_certificate_verification => false
    ssl => true
  }

 stdout {
    codec => rubydebug
}

# stdout {
#    codec => json 
# }

}
